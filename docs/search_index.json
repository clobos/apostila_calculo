[["index.html", "Apostila de Cálculo Capítulo 1 About 1.1 Usage 1.2 Render book 1.3 Preview book", " Apostila de Cálculo Cristian Villegas 2023-02-22 Capítulo 1 About This is a sample book written in Markdown. You can use anything that Pandoc’s Markdown supports; for example, a math equation \\(a^2 + b^2 = c^2\\). 1.1 Usage Each bookdown chapter is an .Rmd file, and each .Rmd file can contain one (and only one) chapter. A chapter must start with a first-level heading: # A good chapter, and can contain one (and only one) first-level heading. Use second-level and higher headings within chapters like: ## A short section or ### An even shorter section. The index.Rmd file is required, and is also your first book chapter. It will be the homepage when you render the book. 1.2 Render book You can render the HTML version of this example book without changing anything: Find the Build pane in the RStudio IDE, and Click on Build Book, then select your output format, or select “All formats” if you’d like to use multiple formats from the same book source files. Or build the book from the R console: bookdown::render_book() To render this example to PDF as a bookdown::pdf_book, you’ll need to install XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.org/tinytex/. 1.3 Preview book As you work, you may start a local server to live preview this HTML book. This preview will update as you edit the book when you save individual .Rmd files. You can start the server in a work session by using the RStudio add-in “Preview book”, or from the R console: bookdown::serve_book() "],["hello-bookdown.html", "Capítulo 2 Hello bookdown 2.1 A section", " Capítulo 2 Hello bookdown All chapters start with a first-level heading followed by your chapter title, like the line above. There should be only one first-level heading (#) per .Rmd file. 2.1 A section All chapter sections start with a second-level (##) or higher heading followed by your section title, like the sections above and below here. You can have as many as you want within a chapter. An unnumbered section Chapters and sections are numbered by default. To un-number a heading, add a {.unnumbered} or the shorter {-} at the end of the heading, like in this section. "],["cross.html", "Capítulo 3 Cross-references 3.1 Chapters and sub-chapters 3.2 Captioned figures and tables", " Capítulo 3 Cross-references Cross-references make it easier for your readers to find and link to elements in your book. 3.1 Chapters and sub-chapters There are two steps to cross-reference any heading: Label the heading: # Hello world {#nice-label}. Leave the label off if you like the automated heading generated based on your heading title: for example, # Hello world = # Hello world {#hello-world}. To label an un-numbered heading, use: # Hello world {-#nice-label} or {# Hello world .unnumbered}. Next, reference the labeled heading anywhere in the text using \\@ref(nice-label); for example, please see Chapter 3. If you prefer text as the link instead of a numbered reference use: any text you want can go here. 3.2 Captioned figures and tables Figures and tables with captions can also be cross-referenced from elsewhere in your book using \\@ref(fig:chunk-label) and \\@ref(tab:chunk-label), respectively. See Figure 3.1. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 3.1: Here is a nice figure! Don’t miss Table 3.1. knitr::kable( head(pressure, 10), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 3.1: Here is a nice table! temperature pressure 0 0.0002 20 0.0012 40 0.0060 60 0.0300 80 0.0900 100 0.2700 120 0.7500 140 1.8500 160 4.2000 180 8.8000 "],["parts.html", "Capítulo 4 Parts", " Capítulo 4 Parts You can add parts to organize one or more book chapters together. Parts can be inserted at the top of an .Rmd file, before the first-level chapter heading in that same file. Add a numbered part: # (PART) Act one {-} (followed by # A chapter) Add an unnumbered part: # (PART\\*) Act one {-} (followed by # A chapter) Add an appendix as a special kind of un-numbered part: # (APPENDIX) Other stuff {-} (followed by # A chapter). Chapters in an appendix are prepended with letters instead of numbers. "],["footnotes-and-citations.html", "Capítulo 5 Footnotes and citations 5.1 Footnotes 5.2 Citations", " Capítulo 5 Footnotes and citations 5.1 Footnotes Footnotes are put inside the square brackets after a caret ^[]. Like this one 1. 5.2 Citations Reference items in your bibliography file(s) using @key. For example, we are using the bookdown package (Xie 2022) (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and knitr (Xie 2015) (this citation was added manually in an external file book.bib). Note that the .bib files need to be listed in the index.Rmd with the YAML bibliography key. The RStudio Visual Markdown Editor can also make it easier to insert citations: https://rstudio.github.io/visual-markdown-editing/#/citations References "],["blocks.html", "Capítulo 6 Blocks 6.1 Equations 6.2 Theorems and proofs 6.3 Callout blocks", " Capítulo 6 Blocks 6.1 Equations Here is an equation. \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{6.1} \\end{equation}\\] You may refer to using \\@ref(eq:binom), like see Equation (6.1). 6.2 Theorems and proofs Labeled theorems can be referenced in text using \\@ref(thm:tri), for example, check out this smart theorem 6.1. Theorem 6.1 For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] Read more here https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html. 6.3 Callout blocks The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html "],["sharing-your-book.html", "Capítulo 7 Sharing your book 7.1 Publishing 7.2 404 pages 7.3 Metadata for sharing", " Capítulo 7 Sharing your book 7.1 Publishing HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html 7.2 404 pages By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you’d like to customize your 404 page instead of using the default, you may add either a _404.Rmd or _404.md file to your project root and use code and/or Markdown syntax. 7.3 Metadata for sharing Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the index.Rmd YAML. To setup, set the url for your book and the path to your cover-image file. Your book’s title and description are also used. This gitbook uses the same social sharing data across all chapters in your book- all links shared will look the same. Specify your book’s source repository on GitHub using the edit key under the configuration options in the _output.yml file, which allows users to suggest an edit by linking to a chapter’s source file. Read more about the features of this output format here: https://pkgs.rstudio.com/bookdown/reference/gitbook.html Or use: ?bookdown::gitbook "],["references.html", "References", " References "],["dplyr.html", "Capítulo 8 Data Wrangling 8.1 Learning Objectives 8.2 Setup 8.3 Six main dplyr verbs 8.4 Additional dplyr one-table verbs 8.5 Window functions 8.6 Extra (yo) 8.7 Further Resources", " Capítulo 8 Data Wrangling 8.1 Learning Objectives Basic Be able to use the 6 main dplyr one-table verbs: (video) select() filter() arrange() mutate() summarise() group_by() Be able to wrangle data by chaining tidyr and dplyr functions (video) Be able to use these additional one-table verbs: (video) rename() distinct() count() slice() pull() Intermediate Fine control of select() operations (video) Use window functions (video) 8.2 Setup Open your reprores-class-notes project Create a new R Markdown file called 07-dplyr.Rmd Update the YAML header Replace the setup chunk with the one below: knitr::opts_chunk$set(echo = TRUE) # packages needed for this chapter library(tidyverse) library(lubridate) # handling dates and times #library(reprores) # class-specific datasets set.seed(8675309) # makes sure random numbers are reproducible Download the Data transformation cheat sheet. 8.2.1 The disgust dataset These examples will use data from reprores::disgust, which contains data from the Three Domain Disgust Scale. Each participant is identified by a unique user_id and each questionnaire completion has a unique id. Look at the Help for this dataset to see the individual questions. disgust &lt;- read_csv(&quot;disgust.csv&quot;) glimpse(disgust) ## Rows: 20,000 ## Columns: 24 ## $ id &lt;dbl&gt; 1199, 1, 1599, 13332, 23, 1160, 7980, 552, 37829, 6902, 6158… ## $ user_id &lt;dbl&gt; 0, 1, 2, 2118, 2311, 3630, 4458, 4651, 4976, 5469, 6066, 609… ## $ date &lt;date&gt; 2008-10-07, 2008-07-10, 2008-10-27, 2012-01-02, 2008-07-15,… ## $ moral1 &lt;dbl&gt; 5, 2, 1, 0, 4, 1, 3, 2, 6, 0, 4, 1, 1, 4, 2, 1, NA, 3, 1, 3,… ## $ moral2 &lt;dbl&gt; 6, 2, 1, 1, 4, 5, 4, 4, 6, 1, 5, 2, 4, 4, 5, 3, NA, 5, 2, 3,… ## $ moral3 &lt;dbl&gt; 4, 1, 1, 1, 4, NA, 3, 3, 6, 3, 6, 2, 3, 4, 4, 2, NA, 4, 3, 3… ## $ moral4 &lt;dbl&gt; 6, 2, 1, 1, 4, 5, 4, 5, 0, 4, 5, 2, 4, 4, 6, 4, NA, 5, 2, 3,… ## $ moral5 &lt;dbl&gt; 5, 1, NA, 1, 4, 5, 4, 5, 6, 1, 5, 1, 3, 3, 5, 5, NA, 3, 2, 3… ## $ moral6 &lt;dbl&gt; 5, 1, NA, 2, 4, 5, 3, 5, 0, 0, 4, 2, 4, 3, 4, 4, NA, 4, 3, 0… ## $ moral7 &lt;dbl&gt; 6, 1, 1, 1, 4, 1, 3, 3, 0, 1, 4, 1, 3, 2, 5, 4, NA, 3, 4, 3,… ## $ sexual1 &lt;dbl&gt; 4, 3, 1, 4, 2, 0, 2, 4, 0, 3, 3, 1, 1, 4, 2, 0, NA, 1, 3, 2,… ## $ sexual2 &lt;dbl&gt; 0, 1, NA, 3, 1, 5, 4, 2, 0, 5, 0, 0, 0, 2, 1, 0, NA, 3, 0, 0… ## $ sexual3 &lt;dbl&gt; 1, 1, 1, 0, 2, 0, 3, 4, 0, 2, 1, 0, 0, 1, 0, 0, NA, 3, 0, 6,… ## $ sexual4 &lt;dbl&gt; 0, 2, NA, 6, 1, 2, 2, 6, 0, 4, 6, 3, 1, 3, 2, 0, NA, 5, 2, 6… ## $ sexual5 &lt;dbl&gt; 1, 1, 1, 0, 1, 0, 1, 6, 0, 6, 3, 0, 0, 2, 1, 0, NA, 5, 0, 2,… ## $ sexual6 &lt;dbl&gt; 4, 2, NA, 3, 1, 1, 5, 6, 0, 6, 5, 4, 2, 3, 4, 0, NA, 3, 3, 6… ## $ sexual7 &lt;dbl&gt; 5, 2, NA, 5, 5, 0, 4, 2, 0, 5, 3, 4, 1, 6, 3, 0, NA, 3, 5, 3… ## $ pathogen1 &lt;dbl&gt; 6, 3, NA, 5, 5, 6, 6, 5, 6, 5, 6, 4, 4, 5, 3, 5, NA, 4, 4, 3… ## $ pathogen2 &lt;dbl&gt; 1, 2, NA, 6, 5, 3, 4, 6, 6, 2, 5, 3, 4, 2, 3, 4, NA, 5, 4, 2… ## $ pathogen3 &lt;dbl&gt; 6, 3, 1, 4, 4, 1, 4, 6, 6, 4, 5, 1, 3, 0, 2, 3, NA, 3, 3, 5,… ## $ pathogen4 &lt;dbl&gt; 5, 3, NA, 6, 4, 1, 3, 4, 6, 4, 5, 1, 4, 4, 4, 1, NA, 5, 4, 0… ## $ pathogen5 &lt;dbl&gt; 4, 2, NA, 5, 5, 3, 3, 6, 0, 2, 5, 4, 5, 5, 5, 4, NA, 4, 4, 5… ## $ pathogen6 &lt;dbl&gt; 5, 3, NA, 5, 4, 1, 2, 1, 0, 2, 5, 1, 4, 5, 1, 2, NA, 5, 5, 5… ## $ pathogen7 &lt;dbl&gt; 6, 3, NA, 4, 3, 0, 3, 6, 6, 6, 5, 3, 5, 4, 5, 3, NA, 5, 2, 6… 8.3 Six main dplyr verbs The six main dplyr verbs: select, filter, arrange, mutate, summarise, and group_by. 8.3.1 select() Select columns by name or number. You can select each column individually, separated by commas (e.g., col1, col2). You can also select all columns between two columns by separating them with a colon (e.g., start_col:end_col). moral &lt;- disgust %&gt;% select(user_id, moral1:moral7) names(moral) ## [1] &quot;user_id&quot; &quot;moral1&quot; &quot;moral2&quot; &quot;moral3&quot; &quot;moral4&quot; &quot;moral5&quot; &quot;moral6&quot; ## [8] &quot;moral7&quot; You can select columns by number, which is useful when the column names are long or complicated. sexual &lt;- disgust %&gt;% select(2, 11:17) names(sexual) ## [1] &quot;user_id&quot; &quot;sexual1&quot; &quot;sexual2&quot; &quot;sexual3&quot; &quot;sexual4&quot; &quot;sexual5&quot; &quot;sexual6&quot; ## [8] &quot;sexual7&quot; You can use a minus symbol to unselect columns, leaving all of the other columns. If you want to exclude a span of columns, put parentheses around the span first (e.g., -(moral1:moral7), not -moral1:moral7). pathogen &lt;- disgust %&gt;% select(-id, -date, -(moral1:sexual7)) names(pathogen) ## [1] &quot;user_id&quot; &quot;pathogen1&quot; &quot;pathogen2&quot; &quot;pathogen3&quot; &quot;pathogen4&quot; &quot;pathogen5&quot; ## [7] &quot;pathogen6&quot; &quot;pathogen7&quot; 8.3.1.1 Select helpers You can select columns based on criteria about the column names. 8.3.1.1.1 starts_with() Select columns that start with a character string. u &lt;- disgust %&gt;% select(starts_with(&quot;u&quot;)) names(u) ## [1] &quot;user_id&quot; 8.3.1.1.2 ends_with() Select columns that end with a character string. firstq &lt;- disgust %&gt;% select(ends_with(&quot;1&quot;)) names(firstq) ## [1] &quot;moral1&quot; &quot;sexual1&quot; &quot;pathogen1&quot; 8.3.1.1.3 contains() Select columns that contain a character string. pathogen &lt;- disgust %&gt;% select(contains(&quot;pathogen&quot;)) names(pathogen) ## [1] &quot;pathogen1&quot; &quot;pathogen2&quot; &quot;pathogen3&quot; &quot;pathogen4&quot; &quot;pathogen5&quot; &quot;pathogen6&quot; ## [7] &quot;pathogen7&quot; 8.3.1.1.4 num_range() Select columns with a name that matches the pattern prefix. moral2_4 &lt;- disgust %&gt;% select(num_range(&quot;moral&quot;, 2:4)) names(moral2_4) ## [1] &quot;moral2&quot; &quot;moral3&quot; &quot;moral4&quot; Use width to set the number of digits with leading zeros. For example, num_range('var_', 8:10, width=2) selects columns var_08, var_09, and var_10. 8.3.2 filter() Select rows by matching column criteria. Select all rows where the user_id is 1 (that’s Lisa). disgust %&gt;% filter(user_id == 1) ## # A tibble: 1 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 2008-07-10 2 2 1 2 1 1 1 ## # … with 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, sexual3 &lt;dbl&gt;, ## # sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; Remember to use == and not = to check if two things are equivalent. A single = assigns the righthand value to the lefthand variable and (usually) evaluates to TRUE. You can select on multiple criteria by separating them with commas. amoral &lt;- disgust %&gt;% filter( moral1 == 0, moral2 == 0, moral3 == 0, moral4 == 0, moral5 == 0, moral6 == 0, moral7 == 0 ) amoral ## # A tibble: 216 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 710 44759 2008-08-26 0 0 0 0 0 0 0 ## 2 7036 88227 2011-01-16 0 0 0 0 0 0 0 ## 3 43 156076 2008-07-18 0 0 0 0 0 0 0 ## 4 89 156634 2008-07-22 0 0 0 0 0 0 0 ## 5 93 156722 2008-07-23 0 0 0 0 0 0 0 ## 6 170 157975 2008-08-03 0 0 0 0 0 0 0 ## 7 414 161765 2008-08-21 0 0 0 0 0 0 0 ## 8 475 162435 2008-08-22 0 0 0 0 0 0 0 ## 9 560 163796 2008-08-24 0 0 0 0 0 0 0 ## 10 638 164674 2008-08-25 0 0 0 0 0 0 0 ## # … with 206 more rows, and 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, ## # sexual3 &lt;dbl&gt;, sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; You can use the symbols &amp;, |, and ! to mean “and”, “or”, and “not”. You can also use other operators to make equations. # everyone who chose either 0 or 7 for question moral1 moral_extremes &lt;- disgust %&gt;% filter(moral1 == 0 | moral1 == 7) moral_extremes ## # A tibble: 2,208 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 13332 2118 2012-01-02 0 1 1 1 1 2 1 ## 2 6902 5469 2010-12-06 0 1 3 4 1 0 1 ## 3 1772 11381 2008-11-03 0 0 0 4 0 0 0 ## 4 710 44759 2008-08-26 0 0 0 0 0 0 0 ## 5 20306 56604 2013-01-17 0 1 0 5 3 1 1 ## 6 7122 71437 2011-02-10 0 1 0 3 1 0 1 ## 7 1230 87584 2008-10-10 0 4 6 4 6 6 0 ## 8 7036 88227 2011-01-16 0 0 0 0 0 0 0 ## 9 14330 92576 2012-02-23 0 6 0 4 0 5 4 ## 10 1821 101243 2008-11-04 0 5 4 5 5 2 2 ## # … with 2,198 more rows, and 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, ## # sexual3 &lt;dbl&gt;, sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; # everyone who chose the same answer for all moral questions moral_consistent &lt;- disgust %&gt;% filter( moral2 == moral1 &amp; moral3 == moral1 &amp; moral4 == moral1 &amp; moral5 == moral1 &amp; moral6 == moral1 &amp; moral7 == moral1 ) moral_consistent ## # A tibble: 623 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 23 2311 2008-07-15 4 4 4 4 4 4 4 ## 2 26188 34951 2014-01-04 6 6 6 6 6 6 6 ## 3 710 44759 2008-08-26 0 0 0 0 0 0 0 ## 4 2673 67077 2009-01-05 6 6 6 6 6 6 6 ## 5 152 72482 2008-07-30 6 6 6 6 6 6 6 ## 6 7036 88227 2011-01-16 0 0 0 0 0 0 0 ## 7 18898 93123 2012-11-03 6 6 6 6 6 6 6 ## 8 3560 95309 2009-05-04 5 5 5 5 5 5 5 ## 9 15649 104323 2012-05-01 6 6 6 6 6 6 6 ## 10 35250 133155 2015-07-16 6 6 6 6 6 6 6 ## # … with 613 more rows, and 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, ## # sexual3 &lt;dbl&gt;, sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; # everyone who did not answer 7 for all 7 moral questions moral_no_ceiling &lt;- disgust %&gt;% filter(moral1+moral2+moral3+moral4+moral5+moral6+moral7 != 7*7) moral_no_ceiling ## # A tibble: 19,224 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1199 0 2008-10-07 5 6 4 6 5 5 6 ## 2 1 1 2008-07-10 2 2 1 2 1 1 1 ## 3 13332 2118 2012-01-02 0 1 1 1 1 2 1 ## 4 23 2311 2008-07-15 4 4 4 4 4 4 4 ## 5 7980 4458 2011-09-05 3 4 3 4 4 3 3 ## 6 552 4651 2008-08-23 2 4 3 5 5 5 3 ## 7 37829 4976 2016-03-22 6 6 6 0 6 0 0 ## 8 6902 5469 2010-12-06 0 1 3 4 1 0 1 ## 9 6158 6066 2010-04-18 4 5 6 5 5 4 4 ## 10 4850 6093 2009-11-09 1 2 2 2 1 2 1 ## # … with 19,214 more rows, and 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, ## # sexual3 &lt;dbl&gt;, sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; 8.3.2.1 Match operator (%in%) Sometimes you need to exclude some participant IDs for reasons that can’t be described in code. The match operator (%in%) is useful here for testing if a column value is in a list. Surround the equation with parentheses and put ! in front to test that a value is not in the list. no_researchers &lt;- disgust %&gt;% filter(!(user_id %in% c(1,2))) no_researchers ## # A tibble: 19,998 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1199 0 2008-10-07 5 6 4 6 5 5 6 ## 2 13332 2118 2012-01-02 0 1 1 1 1 2 1 ## 3 23 2311 2008-07-15 4 4 4 4 4 4 4 ## 4 1160 3630 2008-10-06 1 5 NA 5 5 5 1 ## 5 7980 4458 2011-09-05 3 4 3 4 4 3 3 ## 6 552 4651 2008-08-23 2 4 3 5 5 5 3 ## 7 37829 4976 2016-03-22 6 6 6 0 6 0 0 ## 8 6902 5469 2010-12-06 0 1 3 4 1 0 1 ## 9 6158 6066 2010-04-18 4 5 6 5 5 4 4 ## 10 4850 6093 2009-11-09 1 2 2 2 1 2 1 ## # … with 19,988 more rows, and 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, ## # sexual3 &lt;dbl&gt;, sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; 8.3.2.2 Dates You can use the lubridate package to work with dates. For example, you can use the year() function to return just the year from the date column and then select only data collected in 2010. disgust2010 &lt;- disgust %&gt;% filter(year(date) == 2010) disgust2010 ## # A tibble: 1,514 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6902 5469 2010-12-06 0 1 3 4 1 0 1 ## 2 6158 6066 2010-04-18 4 5 6 5 5 4 4 ## 3 6362 7129 2010-06-09 4 4 4 4 3 3 2 ## 4 6302 39318 2010-05-20 2 4 1 4 5 6 0 ## 5 5429 43029 2010-01-02 1 1 1 3 6 4 2 ## 6 6732 71955 2010-10-15 2 5 3 6 3 2 5 ## 7 6367 84622 2010-06-13 4 6 6 6 6 6 6 ## 8 6476 93120 2010-07-12 3 6 4 6 5 3 4 ## 9 5778 96537 2010-03-05 5 5 3 4 5 5 5 ## 10 6181 131633 2010-04-23 0 6 4 6 0 6 6 ## # … with 1,504 more rows, and 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, ## # sexual3 &lt;dbl&gt;, sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; disgust %&gt;% filter(month(date) == 10) %&gt;% head() ## # A tibble: 6 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1199 0 2008-10-07 5 6 4 6 5 5 6 ## 2 1599 2 2008-10-27 1 1 1 1 NA NA 1 ## 3 1160 3630 2008-10-06 1 5 NA 5 5 5 1 ## 4 1134 6172 2008-10-05 1 4 3 4 3 4 3 ## 5 11322 11395 2011-10-31 1 5 4 4 5 3 4 ## 6 10307 12820 2011-10-02 4 4 2 4 4 4 4 ## # … with 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, sexual3 &lt;dbl&gt;, ## # sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; disgust %&gt;% filter(day(date) == 01) %&gt;% head() ## # A tibble: 6 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2353 37579 2008-12-01 6 6 5 6 6 6 5 ## 2 3455 53597 2009-05-01 3 5 3 4 6 2 5 ## 3 21592 74780 2013-04-01 3 4 3 5 3 4 4 ## 4 28321 89355 2014-04-01 5 5 5 3 6 4 5 ## 5 163 100115 2008-08-01 2 4 1 2 4 5 2 ## 6 15649 104323 2012-05-01 6 6 6 6 6 6 6 ## # … with 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, sexual3 &lt;dbl&gt;, ## # sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; disgust %&gt;% filter(year(date) == 2010) %&gt;% head() ## # A tibble: 6 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6902 5469 2010-12-06 0 1 3 4 1 0 1 ## 2 6158 6066 2010-04-18 4 5 6 5 5 4 4 ## 3 6362 7129 2010-06-09 4 4 4 4 3 3 2 ## 4 6302 39318 2010-05-20 2 4 1 4 5 6 0 ## 5 5429 43029 2010-01-02 1 1 1 3 6 4 2 ## 6 6732 71955 2010-10-15 2 5 3 6 3 2 5 ## # … with 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, sexual3 &lt;dbl&gt;, ## # sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; #dmy(200223) Or select data from at least 5 years ago. You can use the range function to check the minimum and maximum dates in the resulting dataset. disgust_5ago &lt;- disgust %&gt;% filter(date &lt; today() - dyears(5)) disgust_5ago ## # A tibble: 20,000 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1199 0 2008-10-07 5 6 4 6 5 5 6 ## 2 1 1 2008-07-10 2 2 1 2 1 1 1 ## 3 1599 2 2008-10-27 1 1 1 1 NA NA 1 ## 4 13332 2118 2012-01-02 0 1 1 1 1 2 1 ## 5 23 2311 2008-07-15 4 4 4 4 4 4 4 ## 6 1160 3630 2008-10-06 1 5 NA 5 5 5 1 ## 7 7980 4458 2011-09-05 3 4 3 4 4 3 3 ## 8 552 4651 2008-08-23 2 4 3 5 5 5 3 ## 9 37829 4976 2016-03-22 6 6 6 0 6 0 0 ## 10 6902 5469 2010-12-06 0 1 3 4 1 0 1 ## # … with 19,990 more rows, and 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, ## # sexual3 &lt;dbl&gt;, sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; range(disgust_5ago$date) ## [1] &quot;2008-07-10&quot; &quot;2017-08-21&quot; today() ## [1] &quot;2023-02-22&quot; dyears(5) ## [1] &quot;157788000s (~5 years)&quot; 8.3.3 arrange() Sort your dataset using arrange(). You will find yourself needing to sort data in R much less than you do in Excel, since you don’t need to have rows next to each other in order to, for example, calculate group means. But arrange() can be useful when preparing data from display in tables. disgust_order &lt;- disgust %&gt;% arrange(date, moral1) disgust_order ## # A tibble: 20,000 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 2008-07-10 2 2 1 2 1 1 1 ## 2 3 155324 2008-07-11 2 4 3 5 2 1 4 ## 3 6 155386 2008-07-12 2 4 0 4 0 0 0 ## 4 7 155409 2008-07-12 4 5 5 4 5 1 5 ## 5 4 155366 2008-07-12 6 6 6 3 6 6 6 ## 6 5 155370 2008-07-12 6 6 4 6 6 6 6 ## 7 14 155129 2008-07-13 2 6 0 5 2 0 2 ## 8 8 155427 2008-07-13 2 5 2 6 3 2 3 ## 9 10 155429 2008-07-13 2 6 4 6 0 5 3 ## 10 9 155425 2008-07-13 3 6 3 5 6 3 5 ## # … with 19,990 more rows, and 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, ## # sexual3 &lt;dbl&gt;, sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; Reverse the order using desc() disgust_order_desc &lt;- disgust %&gt;% arrange(desc(date)) disgust_order_desc ## # A tibble: 20,000 × 24 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 39456 356866 2017-08-21 1 1 1 1 1 1 1 ## 2 39447 128727 2017-08-13 2 4 1 2 2 5 3 ## 3 39371 152955 2017-06-13 6 6 3 6 6 6 6 ## 4 39342 48303 2017-05-22 4 5 4 4 6 4 5 ## 5 39159 151633 2017-04-04 4 5 6 5 3 6 2 ## 6 38942 370464 2017-02-01 1 5 0 6 5 5 5 ## 7 38710 453237 2016-11-24 0 0 0 0 0 0 0 ## 8 38359 449337 2016-09-20 6 6 6 5 6 4 5 ## 9 38222 51771 2016-08-04 2 6 4 6 6 5 4 ## 10 38020 452964 2016-05-22 2 6 4 6 6 3 6 ## # … with 19,990 more rows, and 14 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, ## # sexual3 &lt;dbl&gt;, sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt; 8.3.4 mutate() Add new columns. This is one of the most useful functions in the tidyverse. Refer to other columns by their names (unquoted). You can add more than one column in the same mutate function, just separate the columns with a comma. Once you make a new column, you can use it in further column definitions e.g., total below). disgust_total &lt;- disgust %&gt;% mutate( pathogen = pathogen1 + pathogen2 + pathogen3 + pathogen4 + pathogen5 + pathogen6 + pathogen7, moral = moral1 + moral2 + moral3 + moral4 + moral5 + moral6 + moral7, sexual = sexual1 + sexual2 + sexual3 + sexual4 + sexual5 + sexual6 + sexual7, total = pathogen + moral + sexual, user_id = paste0(&quot;U&quot;, user_id) ) disgust_total ## # A tibble: 20,000 × 28 ## id user_id date moral1 moral2 moral3 moral4 moral5 moral6 moral7 ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1199 U0 2008-10-07 5 6 4 6 5 5 6 ## 2 1 U1 2008-07-10 2 2 1 2 1 1 1 ## 3 1599 U2 2008-10-27 1 1 1 1 NA NA 1 ## 4 13332 U2118 2012-01-02 0 1 1 1 1 2 1 ## 5 23 U2311 2008-07-15 4 4 4 4 4 4 4 ## 6 1160 U3630 2008-10-06 1 5 NA 5 5 5 1 ## 7 7980 U4458 2011-09-05 3 4 3 4 4 3 3 ## 8 552 U4651 2008-08-23 2 4 3 5 5 5 3 ## 9 37829 U4976 2016-03-22 6 6 6 0 6 0 0 ## 10 6902 U5469 2010-12-06 0 1 3 4 1 0 1 ## # … with 19,990 more rows, and 18 more variables: sexual1 &lt;dbl&gt;, sexual2 &lt;dbl&gt;, ## # sexual3 &lt;dbl&gt;, sexual4 &lt;dbl&gt;, sexual5 &lt;dbl&gt;, sexual6 &lt;dbl&gt;, sexual7 &lt;dbl&gt;, ## # pathogen1 &lt;dbl&gt;, pathogen2 &lt;dbl&gt;, pathogen3 &lt;dbl&gt;, pathogen4 &lt;dbl&gt;, ## # pathogen5 &lt;dbl&gt;, pathogen6 &lt;dbl&gt;, pathogen7 &lt;dbl&gt;, pathogen &lt;dbl&gt;, ## # moral &lt;dbl&gt;, sexual &lt;dbl&gt;, total &lt;dbl&gt; disgust_total %&gt;% select(pathogen, moral, sexual, total) ## # A tibble: 20,000 × 4 ## pathogen moral sexual total ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 33 37 15 85 ## 2 19 10 12 41 ## 3 NA NA NA NA ## 4 35 7 21 63 ## 5 30 28 13 71 ## 6 15 NA 8 NA ## 7 25 24 21 70 ## 8 34 27 30 91 ## 9 30 24 0 54 ## 10 25 10 31 66 ## # … with 19,990 more rows You can overwrite a column by giving a new column the same name as the old column (see user_id) above. Make sure that you mean to do this and that you aren’t trying to use the old column value after you redefine it. 8.3.5 summarise() Create summary statistics for the dataset. Check the Data Wrangling Cheat Sheet or the Data Transformation Cheat Sheet for various summary functions. Some common ones are: mean(), sd(), n(), sum(), and quantile(). disgust_summary&lt;- disgust_total %&gt;% summarise( n = n(), q25 = quantile(total, .25, na.rm = TRUE), q50 = quantile(total, .50, na.rm = TRUE), q75 = quantile(total, .75, na.rm = TRUE), avg_total = mean(total, na.rm = TRUE), sd_total = sd(total, na.rm = TRUE), min_total = min(total, na.rm = TRUE), max_total = max(total, na.rm = TRUE) ) disgust_summary ## # A tibble: 1 × 8 ## n q25 q50 q75 avg_total sd_total min_total max_total ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20000 59 71 83 70.7 18.2 0 126 8.3.6 group_by() Create subsets of the data. You can use this to create summaries, like the mean value for all of your experimental groups. Here, we’ll use mutate to create a new column called year, group by year, and calculate the average scores. disgust_groups &lt;- disgust_total %&gt;% mutate(year = year(date)) %&gt;% group_by(year) %&gt;% summarise( n = n(), avg_total = mean(total, na.rm = TRUE), sd_total = sd(total, na.rm = TRUE), min_total = min(total, na.rm = TRUE), max_total = max(total, na.rm = TRUE), .groups = &quot;drop&quot; ) disgust_groups ## # A tibble: 10 × 6 ## year n avg_total sd_total min_total max_total ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2008 2578 70.3 18.5 0 126 ## 2 2009 2580 69.7 18.6 3 126 ## 3 2010 1514 70.6 18.9 6 126 ## 4 2011 6046 71.3 17.8 0 126 ## 5 2012 5938 70.4 18.4 0 126 ## 6 2013 1251 71.6 17.6 0 126 ## 7 2014 58 70.5 17.2 19 113 ## 8 2015 21 74.3 16.9 43 107 ## 9 2016 8 67.9 32.6 0 110 ## 10 2017 6 57.2 27.9 21 90 ` If you don’t add .groups = \"drop\" at the end of the summarise() function, you will get the following message: “summarise() ungrouping output (override with .groups argument)”. This just reminds you that the groups are still in effect and any further functions will also be grouped. Older versions of dplyr didn’t do this, so older code will generate this warning if you run it with newer version of dplyr. Older code might ungroup() after summarise() to indicate that groupings should be dropped. The default behaviour is usually correct, so you don’t need to worry, but it’s best to explicitly set .groups in a summarise() function after group_by() if you want to “keep” or “drop” the groupings. You can use filter after group_by. The following example returns the lowest total score from each year (i.e., the row where the rank() of the value in the column total is equivalent to 1). disgust_lowest &lt;- disgust_total %&gt;% mutate(year = year(date)) %&gt;% select(user_id, year, total) %&gt;% group_by(year) %&gt;% filter(rank(total) == 1) %&gt;% arrange(year) disgust_lowest ## # A tibble: 7 × 3 ## # Groups: year [7] ## user_id year total ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 U236585 2009 3 ## 2 U292359 2010 6 ## 3 U245384 2013 0 ## 4 U206293 2014 19 ## 5 U407089 2015 43 ## 6 U453237 2016 0 ## 7 U356866 2017 21 You can also use mutate after group_by. The following example calculates subject-mean-centered scores by grouping the scores by user_id and then subtracting the group-specific mean from each score. Note the use of gather to tidy the data into a long format first. disgust_smc &lt;- disgust %&gt;% gather(&quot;question&quot;, &quot;score&quot;, moral1:pathogen7) %&gt;% group_by(user_id) %&gt;% mutate(score_smc = score - mean(score, na.rm = TRUE)) %&gt;% ungroup() disgust_smc ## # A tibble: 420,000 × 6 ## id user_id date question score score_smc ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1199 0 2008-10-07 moral1 5 0.952 ## 2 1 1 2008-07-10 moral1 2 0.0476 ## 3 1599 2 2008-10-27 moral1 1 0 ## 4 13332 2118 2012-01-02 moral1 0 -3 ## 5 23 2311 2008-07-15 moral1 4 0.619 ## 6 1160 3630 2008-10-06 moral1 1 -1.25 ## 7 7980 4458 2011-09-05 moral1 3 -0.333 ## 8 552 4651 2008-08-23 moral1 2 -2.33 ## 9 37829 4976 2016-03-22 moral1 6 3.43 ## 10 6902 5469 2010-12-06 moral1 0 -3.14 ## # … with 419,990 more rows Use ungroup() as soon as you are done with grouped functions, otherwise the data table will still be grouped when you use it in the future. 8.3.7 All Together A lot of what we did above would be easier if the data were tidy, so let’s do that first. Then we can use group_by to calculate the domain scores. After that, we can spread out the 3 domains, calculate the total score, remove any rows with a missing (NA) total, and calculate mean values by year. disgust_tidy &lt;- disgust %&gt;% gather(&quot;question&quot;, &quot;score&quot;, moral1:pathogen7) %&gt;% separate(question, c(&quot;domain&quot;,&quot;q_num&quot;), sep = -1) %&gt;% group_by(id, user_id, date, domain) %&gt;% summarise(score = mean(score), .groups = &quot;drop&quot;) disgust_tidy ## # A tibble: 60,000 × 5 ## id user_id date domain score ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 1 2008-07-10 moral 1.43 ## 2 1 1 2008-07-10 pathogen 2.71 ## 3 1 1 2008-07-10 sexual 1.71 ## 4 3 155324 2008-07-11 moral 3 ## 5 3 155324 2008-07-11 pathogen 2.57 ## 6 3 155324 2008-07-11 sexual 1.86 ## 7 4 155366 2008-07-12 moral 5.57 ## 8 4 155366 2008-07-12 pathogen 4 ## 9 4 155366 2008-07-12 sexual 0.429 ## 10 5 155370 2008-07-12 moral 5.71 ## # … with 59,990 more rows disgust_scored &lt;- disgust_tidy %&gt;% spread(domain, score) %&gt;% mutate( total = moral + sexual + pathogen, year = year(date) ) %&gt;% filter(!is.na(total)) %&gt;% arrange(user_id) disgust_scored ## # A tibble: 18,490 × 8 ## id user_id date moral pathogen sexual total year ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1199 0 2008-10-07 5.29 4.71 2.14 12.1 2008 ## 2 1 1 2008-07-10 1.43 2.71 1.71 5.86 2008 ## 3 13332 2118 2012-01-02 1 5 3 9 2012 ## 4 23 2311 2008-07-15 4 4.29 1.86 10.1 2008 ## 5 7980 4458 2011-09-05 3.43 3.57 3 10 2011 ## 6 552 4651 2008-08-23 3.86 4.86 4.29 13 2008 ## 7 37829 4976 2016-03-22 3.43 4.29 0 7.71 2016 ## 8 6902 5469 2010-12-06 1.43 3.57 4.43 9.43 2010 ## 9 6158 6066 2010-04-18 4.71 5.14 3 12.9 2010 ## 10 4850 6093 2009-11-09 1.57 2.43 1.71 5.71 2009 ## # … with 18,480 more rows disgust_summarised &lt;- disgust_scored %&gt;% group_by(year) %&gt;% summarise( n = n(), avg_pathogen = mean(pathogen), avg_moral = mean(moral), avg_sexual = mean(sexual), first_user = first(user_id), last_user = last(user_id), .groups = &quot;drop&quot; ) disgust_summarised ## # A tibble: 10 × 7 ## year n avg_pathogen avg_moral avg_sexual first_user last_user ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2008 2392 3.70 3.81 2.54 0 188708 ## 2 2009 2410 3.67 3.76 2.53 6093 251959 ## 3 2010 1418 3.73 3.84 2.51 5469 319641 ## 4 2011 5586 3.76 3.81 2.63 4458 406569 ## 5 2012 5375 3.74 3.77 2.55 2118 458194 ## 6 2013 1222 3.77 3.91 2.55 7646 462428 ## 7 2014 54 3.76 4 2.31 11090 461307 ## 8 2015 19 3.78 4.45 2.38 102699 460283 ## 9 2016 8 3.70 3.62 2.38 4976 453237 ## 10 2017 6 3.07 3.69 1.40 48303 370464 8.4 Additional dplyr one-table verbs Use the code examples below and the help pages to figure out what the following one-table verbs do. Most have pretty self-explanatory names. 8.4.1 rename() You can rename columns with rename(). Set the argument name to the new name, and the value to the old name. You need to put a name in quotes or backticks if it doesn’t follow the rules for a good variable name (contains only letter, numbers, underscores, and full stops; and doesn’t start with a number). sw &lt;- starwars %&gt;% rename(Name = name, Height = height, Mass = mass, `Hair Colour` = hair_color, `Skin Colour` = skin_color, `Eye Colour` = eye_color, `Birth Year` = birth_year) sw ## # A tibble: 87 × 14 ## Name Height Mass Hair …¹ Skin …² Eye C…³ Birth…⁴ sex gender homew…⁵ ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke Skywa… 172 77 blond fair blue 19 male mascu… Tatooi… ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu… Tatooi… ## 3 R2-D2 96 32 &lt;NA&gt; white,… red 33 none mascu… Naboo ## 4 Darth Vader 202 136 none white yellow 41.9 male mascu… Tatooi… ## 5 Leia Organa 150 49 brown light brown 19 fema… femin… Aldera… ## 6 Owen Lars 178 120 brown,… light blue 52 male mascu… Tatooi… ## 7 Beru White… 165 75 brown light blue 47 fema… femin… Tatooi… ## 8 R5-D4 97 32 &lt;NA&gt; white,… red NA none mascu… Tatooi… ## 9 Biggs Dark… 183 84 black light brown 24 male mascu… Tatooi… ## 10 Obi-Wan Ke… 182 77 auburn… fair blue-g… 57 male mascu… Stewjon ## # … with 77 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names ## # ¹​`Hair Colour`, ²​`Skin Colour`, ³​`Eye Colour`, ⁴​`Birth Year`, ⁵​homeworld names(sw) ## [1] &quot;Name&quot; &quot;Height&quot; &quot;Mass&quot; &quot;Hair Colour&quot; &quot;Skin Colour&quot; ## [6] &quot;Eye Colour&quot; &quot;Birth Year&quot; &quot;sex&quot; &quot;gender&quot; &quot;homeworld&quot; ## [11] &quot;species&quot; &quot;films&quot; &quot;vehicles&quot; &quot;starships&quot; Almost everyone gets confused at some point with rename() and tries to put the original names on the left and the new names on the right. Try it and see what the error message looks like. 8.4.2 distinct() Get rid of exactly duplicate rows with distinct(). This can be helpful if, for example, you are merging data from multiple computers and some of the data got copied from one computer to another, creating duplicate rows. # create a data table with duplicated values dupes &lt;- tibble( id = c( 1, 2, 1, 2, 1, 2), dv = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;A&quot;, &quot;B&quot;) ) dupes ## # A tibble: 6 × 2 ## id dv ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 A ## 2 2 B ## 3 1 C ## 4 2 D ## 5 1 A ## 6 2 B distinct(dupes) ## # A tibble: 4 × 2 ## id dv ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 A ## 2 2 B ## 3 1 C ## 4 2 D 8.4.3 count() The function count() is a quick shortcut for the common combination of group_by() and summarise() used to count the number of rows per group. starwars %&gt;% group_by(sex) %&gt;% summarise(n = n(), .groups = &quot;drop&quot;) ## # A tibble: 5 × 2 ## sex n ## &lt;chr&gt; &lt;int&gt; ## 1 female 16 ## 2 hermaphroditic 1 ## 3 male 60 ## 4 none 6 ## 5 &lt;NA&gt; 4 count(starwars, sex) ## # A tibble: 5 × 2 ## sex n ## &lt;chr&gt; &lt;int&gt; ## 1 female 16 ## 2 hermaphroditic 1 ## 3 male 60 ## 4 none 6 ## 5 &lt;NA&gt; 4 8.4.4 slice() slice(starwars, 1:3, 10) ## # A tibble: 4 × 14 ## name height mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex gender homew…⁵ ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke Skywal… 172 77 blond fair blue 19 male mascu… Tatooi… ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu… Tatooi… ## 3 R2-D2 96 32 &lt;NA&gt; white,… red 33 none mascu… Naboo ## 4 Obi-Wan Ken… 182 77 auburn… fair blue-g… 57 male mascu… Stewjon ## # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;, ## # starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color, ## # ³​eye_color, ⁴​birth_year, ⁵​homeworld 8.4.5 pull() starwars %&gt;% filter(species == &quot;Droid&quot;) %&gt;% pull(name) ## [1] &quot;C-3PO&quot; &quot;R2-D2&quot; &quot;R5-D4&quot; &quot;IG-88&quot; &quot;R4-P17&quot; &quot;BB8&quot; 8.5 Window functions Window functions use the order of rows to calculate values. You can use them to do things that require ranking or ordering, like choose the top scores in each class, or accessing the previous and next rows, like calculating cumulative sums or means. The dplyr window functions vignette has very good detailed explanations of these functions, but we’ve described a few of the most useful ones below. 8.5.1 Ranking functions grades &lt;- tibble( id = 1:5, &quot;Data Skills&quot; = c(16, 17, 17, 19, 20), &quot;Statistics&quot; = c(14, 16, 18, 18, 19) ) %&gt;% gather(class, grade, 2:3) %&gt;% group_by(class) %&gt;% mutate(row_number = row_number(), rank = rank(grade), min_rank = min_rank(grade), dense_rank = dense_rank(grade), quartile = ntile(grade, 4), percentile = ntile(grade, 100)) grades ## # A tibble: 10 × 9 ## # Groups: class [2] ## id class grade row_number rank min_rank dense_rank quartile perce…¹ ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 Data Skills 16 1 1 1 1 1 1 ## 2 2 Data Skills 17 2 2.5 2 2 1 2 ## 3 3 Data Skills 17 3 2.5 2 2 2 3 ## 4 4 Data Skills 19 4 4 4 3 3 4 ## 5 5 Data Skills 20 5 5 5 4 4 5 ## 6 1 Statistics 14 1 1 1 1 1 1 ## 7 2 Statistics 16 2 2 2 2 1 2 ## 8 3 Statistics 18 3 3.5 3 3 2 3 ## 9 4 Statistics 18 4 3.5 3 3 3 4 ## 10 5 Statistics 19 5 5 5 4 4 5 ## # … with abbreviated variable name ¹​percentile What are the differences among row_number(), rank(), min_rank(), dense_rank(), and ntile()? Why doesn’t row_number() need an argument? What would happen if you gave it the argument grade or class? What do you think would happen if you removed the group_by(class) line above? What if you added id to the grouping? What happens if you change the order of the rows? What does the second argument in ntile() do? You can use window functions to group your data into quantiles. sw_mass &lt;- starwars %&gt;% group_by(tertile = ntile(mass, 3)) %&gt;% summarise(min = min(mass), max = max(mass), mean = mean(mass), .groups = &quot;drop&quot;) sw_mass ## # A tibble: 4 × 4 ## tertile min max mean ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 15 68 45.7 ## 2 2 74 82 78.4 ## 3 3 83 1358 172. ## 4 NA NA NA NA x &lt;- c(5, 1, 3, 2, 2, NA) ntile(x, 2) ## [1] 2 1 2 1 1 NA ntile(x, 4) ## [1] 4 1 3 1 2 NA cut(x,2) ## [1] (3,5] (0.996,3] (0.996,3] (0.996,3] (0.996,3] &lt;NA&gt; ## Levels: (0.996,3] (3,5] cut(x,4) ## [1] (4,5] (0.996,2] (2,3] (0.996,2] (0.996,2] &lt;NA&gt; ## Levels: (0.996,2] (2,3] (3,4] (4,5] Why is there a row of NA values? How would you get rid of them? 8.5.2 Offset functions The function lag() gives a previous row’s value. It defaults to 1 row back, but you can change that with the n argument. The function lead() gives values ahead of the current row. lag_lead &lt;- tibble(x = 1:6) %&gt;% mutate(lag = lag(x), lag2 = lag(x, n = 2), lead = lead(x, default = 0)) lag_lead ## # A tibble: 6 × 4 ## x lag lag2 lead ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 NA NA 2 ## 2 2 1 NA 3 ## 3 3 2 1 4 ## 4 4 3 2 5 ## 5 5 4 3 6 ## 6 6 5 4 0 You can use offset functions to calculate change between trials or where a value changes. Use the order_by argument to specify the order of the rows. Alternatively, you can use arrange() before the offset functions. trials &lt;- tibble( trial = sample(1:10, 10), cond = sample(c(&quot;exp&quot;, &quot;ctrl&quot;), 10, T), score = rpois(10, 4) ) %&gt;% mutate( score_change = score - lag(score, order_by = trial), change_cond = cond != lag(cond, order_by = trial, default = &quot;no condition&quot;) ) %&gt;% arrange(trial) trials ## # A tibble: 10 × 5 ## trial cond score score_change change_cond ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt; ## 1 1 ctrl 8 NA TRUE ## 2 2 ctrl 4 -4 FALSE ## 3 3 exp 6 2 TRUE ## 4 4 ctrl 2 -4 TRUE ## 5 5 ctrl 3 1 FALSE ## 6 6 ctrl 6 3 FALSE ## 7 7 ctrl 2 -4 FALSE ## 8 8 exp 4 2 TRUE ## 9 9 ctrl 4 0 TRUE ## 10 10 exp 3 -1 TRUE Look at the help pages for lag() and lead(). What happens if you remove the order_by argument or change it to cond? What does the default argument do? Can you think of circumstances in your own data where you might need to use lag() or lead()? 8.5.3 Cumulative aggregates cumsum(), cummin(), and cummax() are base R functions for calculating cumulative means, minimums, and maximums. The dplyr package introduces cumany() and cumall(), which return TRUE if any or all of the previous values meet their criteria. cumulative &lt;- tibble( time = 1:10, obs = c(2, 2, 1, 2, 4, 3, 1, 0, 3, 5) ) %&gt;% mutate( cumsum = cumsum(obs), cummin = cummin(obs), cummax = cummax(obs), cumany = cumany(obs == 3), cumall = cumall(obs &lt; 4) ) cumulative ## # A tibble: 10 × 7 ## time obs cumsum cummin cummax cumany cumall ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt; ## 1 1 2 2 2 2 FALSE TRUE ## 2 2 2 4 2 2 FALSE TRUE ## 3 3 1 5 1 2 FALSE TRUE ## 4 4 2 7 1 2 FALSE TRUE ## 5 5 4 11 1 4 FALSE FALSE ## 6 6 3 14 1 4 TRUE FALSE ## 7 7 1 15 1 4 TRUE FALSE ## 8 8 0 15 0 4 TRUE FALSE ## 9 9 3 18 0 4 TRUE FALSE ## 10 10 5 23 0 5 TRUE FALSE What would happen if you change cumany(obs == 3) to cumany(obs &gt; 2)? What would happen if you change cumall(obs &lt; 4) to cumall(obs &lt; 2)? Can you think of circumstances in your own data where you might need to use cumany() or cumall()? 8.6 Extra (yo) iris %&gt;% summarise_if(is.numeric, mean, na.rm = TRUE) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.843333 3.057333 3.758 1.199333 by_species &lt;- iris %&gt;% group_by(Species) by_species ## # A tibble: 150 × 5 ## # Groups: Species [3] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # … with 140 more rows by_species %&gt;% summarise_all(list(min, max)) ## # A tibble: 3 × 9 ## Species Sepal.Len…¹ Sepal…² Petal…³ Petal…⁴ Sepal…⁵ Sepal…⁶ Petal…⁷ Petal…⁸ ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 4.3 2.3 1 0.1 5.8 4.4 1.9 0.6 ## 2 versicolor 4.9 2 3 1 7 3.4 5.1 1.8 ## 3 virginica 4.9 2.2 4.5 1.4 7.9 3.8 6.9 2.5 ## # … with abbreviated variable names ¹​Sepal.Length_fn1, ²​Sepal.Width_fn1, ## # ³​Petal.Length_fn1, ⁴​Petal.Width_fn1, ⁵​Sepal.Length_fn2, ⁶​Sepal.Width_fn2, ## # ⁷​Petal.Length_fn2, ⁸​Petal.Width_fn2 by_species %&gt;% summarise(across(everything(), list(min = min, max = max))) ## # A tibble: 3 × 9 ## Species Sepal.Len…¹ Sepal…² Sepal…³ Sepal…⁴ Petal…⁵ Petal…⁶ Petal…⁷ Petal…⁸ ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 4.3 5.8 2.3 4.4 1 1.9 0.1 0.6 ## 2 versicolor 4.9 7 2 3.4 3 5.1 1 1.8 ## 3 virginica 4.9 7.9 2.2 3.8 4.5 6.9 1.4 2.5 ## # … with abbreviated variable names ¹​Sepal.Length_min, ²​Sepal.Length_max, ## # ³​Sepal.Width_min, ⁴​Sepal.Width_max, ⁵​Petal.Length_min, ⁶​Petal.Length_max, ## # ⁷​Petal.Width_min, ⁸​Petal.Width_max ls(&quot;package:dplyr&quot;) ## [1] &quot;%&gt;%&quot; &quot;across&quot; &quot;add_count&quot; ## [4] &quot;add_count_&quot; &quot;add_row&quot; &quot;add_rownames&quot; ## [7] &quot;add_tally&quot; &quot;add_tally_&quot; &quot;all_equal&quot; ## [10] &quot;all_of&quot; &quot;all_vars&quot; &quot;anti_join&quot; ## [13] &quot;any_of&quot; &quot;any_vars&quot; &quot;arrange&quot; ## [16] &quot;arrange_&quot; &quot;arrange_all&quot; &quot;arrange_at&quot; ## [19] &quot;arrange_if&quot; &quot;as.tbl&quot; &quot;as_data_frame&quot; ## [22] &quot;as_label&quot; &quot;as_tibble&quot; &quot;auto_copy&quot; ## [25] &quot;band_instruments&quot; &quot;band_instruments2&quot; &quot;band_members&quot; ## [28] &quot;bench_tbls&quot; &quot;between&quot; &quot;bind_cols&quot; ## [31] &quot;bind_rows&quot; &quot;c_across&quot; &quot;case_when&quot; ## [34] &quot;changes&quot; &quot;check_dbplyr&quot; &quot;coalesce&quot; ## [37] &quot;collapse&quot; &quot;collect&quot; &quot;combine&quot; ## [40] &quot;common_by&quot; &quot;compare_tbls&quot; &quot;compare_tbls2&quot; ## [43] &quot;compute&quot; &quot;contains&quot; &quot;copy_to&quot; ## [46] &quot;count&quot; &quot;count_&quot; &quot;cumall&quot; ## [49] &quot;cumany&quot; &quot;cume_dist&quot; &quot;cummean&quot; ## [52] &quot;cur_column&quot; &quot;cur_data&quot; &quot;cur_data_all&quot; ## [55] &quot;cur_group&quot; &quot;cur_group_id&quot; &quot;cur_group_rows&quot; ## [58] &quot;current_vars&quot; &quot;data_frame&quot; &quot;data_frame_&quot; ## [61] &quot;db_analyze&quot; &quot;db_begin&quot; &quot;db_commit&quot; ## [64] &quot;db_create_index&quot; &quot;db_create_indexes&quot; &quot;db_create_table&quot; ## [67] &quot;db_data_type&quot; &quot;db_desc&quot; &quot;db_drop_table&quot; ## [70] &quot;db_explain&quot; &quot;db_has_table&quot; &quot;db_insert_into&quot; ## [73] &quot;db_list_tables&quot; &quot;db_query_fields&quot; &quot;db_query_rows&quot; ## [76] &quot;db_rollback&quot; &quot;db_save_query&quot; &quot;db_write_table&quot; ## [79] &quot;dense_rank&quot; &quot;desc&quot; &quot;dim_desc&quot; ## [82] &quot;distinct&quot; &quot;distinct_&quot; &quot;distinct_all&quot; ## [85] &quot;distinct_at&quot; &quot;distinct_if&quot; &quot;distinct_prepare&quot; ## [88] &quot;do&quot; &quot;do_&quot; &quot;dplyr_col_modify&quot; ## [91] &quot;dplyr_reconstruct&quot; &quot;dplyr_row_slice&quot; &quot;ends_with&quot; ## [94] &quot;enexpr&quot; &quot;enexprs&quot; &quot;enquo&quot; ## [97] &quot;enquos&quot; &quot;ensym&quot; &quot;ensyms&quot; ## [100] &quot;eval_tbls&quot; &quot;eval_tbls2&quot; &quot;everything&quot; ## [103] &quot;explain&quot; &quot;expr&quot; &quot;failwith&quot; ## [106] &quot;filter&quot; &quot;filter_&quot; &quot;filter_all&quot; ## [109] &quot;filter_at&quot; &quot;filter_if&quot; &quot;first&quot; ## [112] &quot;frame_data&quot; &quot;full_join&quot; &quot;funs&quot; ## [115] &quot;funs_&quot; &quot;glimpse&quot; &quot;group_by&quot; ## [118] &quot;group_by_&quot; &quot;group_by_all&quot; &quot;group_by_at&quot; ## [121] &quot;group_by_drop_default&quot; &quot;group_by_if&quot; &quot;group_by_prepare&quot; ## [124] &quot;group_cols&quot; &quot;group_data&quot; &quot;group_indices&quot; ## [127] &quot;group_indices_&quot; &quot;group_keys&quot; &quot;group_map&quot; ## [130] &quot;group_modify&quot; &quot;group_nest&quot; &quot;group_rows&quot; ## [133] &quot;group_size&quot; &quot;group_split&quot; &quot;group_trim&quot; ## [136] &quot;group_vars&quot; &quot;group_walk&quot; &quot;grouped_df&quot; ## [139] &quot;groups&quot; &quot;id&quot; &quot;ident&quot; ## [142] &quot;if_all&quot; &quot;if_any&quot; &quot;if_else&quot; ## [145] &quot;inner_join&quot; &quot;intersect&quot; &quot;is.grouped_df&quot; ## [148] &quot;is.src&quot; &quot;is.tbl&quot; &quot;is_grouped_df&quot; ## [151] &quot;lag&quot; &quot;last&quot; &quot;last_col&quot; ## [154] &quot;lead&quot; &quot;left_join&quot; &quot;location&quot; ## [157] &quot;lst&quot; &quot;lst_&quot; &quot;make_tbl&quot; ## [160] &quot;matches&quot; &quot;min_rank&quot; &quot;mutate&quot; ## [163] &quot;mutate_&quot; &quot;mutate_all&quot; &quot;mutate_at&quot; ## [166] &quot;mutate_each&quot; &quot;mutate_each_&quot; &quot;mutate_if&quot; ## [169] &quot;n&quot; &quot;n_distinct&quot; &quot;n_groups&quot; ## [172] &quot;na_if&quot; &quot;near&quot; &quot;nest_by&quot; ## [175] &quot;nest_join&quot; &quot;new_grouped_df&quot; &quot;new_rowwise_df&quot; ## [178] &quot;nth&quot; &quot;ntile&quot; &quot;num_range&quot; ## [181] &quot;one_of&quot; &quot;order_by&quot; &quot;percent_rank&quot; ## [184] &quot;progress_estimated&quot; &quot;pull&quot; &quot;quo&quot; ## [187] &quot;quo_name&quot; &quot;quos&quot; &quot;recode&quot; ## [190] &quot;recode_factor&quot; &quot;relocate&quot; &quot;rename&quot; ## [193] &quot;rename_&quot; &quot;rename_all&quot; &quot;rename_at&quot; ## [196] &quot;rename_if&quot; &quot;rename_vars&quot; &quot;rename_vars_&quot; ## [199] &quot;rename_with&quot; &quot;right_join&quot; &quot;row_number&quot; ## [202] &quot;rows_append&quot; &quot;rows_delete&quot; &quot;rows_insert&quot; ## [205] &quot;rows_patch&quot; &quot;rows_update&quot; &quot;rows_upsert&quot; ## [208] &quot;rowwise&quot; &quot;same_src&quot; &quot;sample_frac&quot; ## [211] &quot;sample_n&quot; &quot;select&quot; &quot;select_&quot; ## [214] &quot;select_all&quot; &quot;select_at&quot; &quot;select_if&quot; ## [217] &quot;select_var&quot; &quot;select_vars&quot; &quot;select_vars_&quot; ## [220] &quot;semi_join&quot; &quot;setdiff&quot; &quot;setequal&quot; ## [223] &quot;show_query&quot; &quot;slice&quot; &quot;slice_&quot; ## [226] &quot;slice_head&quot; &quot;slice_max&quot; &quot;slice_min&quot; ## [229] &quot;slice_sample&quot; &quot;slice_tail&quot; &quot;sql&quot; ## [232] &quot;sql_escape_ident&quot; &quot;sql_escape_string&quot; &quot;sql_join&quot; ## [235] &quot;sql_select&quot; &quot;sql_semi_join&quot; &quot;sql_set_op&quot; ## [238] &quot;sql_subquery&quot; &quot;sql_translate_env&quot; &quot;src&quot; ## [241] &quot;src_df&quot; &quot;src_local&quot; &quot;src_mysql&quot; ## [244] &quot;src_postgres&quot; &quot;src_sqlite&quot; &quot;src_tbls&quot; ## [247] &quot;starts_with&quot; &quot;starwars&quot; &quot;storms&quot; ## [250] &quot;summarise&quot; &quot;summarise_&quot; &quot;summarise_all&quot; ## [253] &quot;summarise_at&quot; &quot;summarise_each&quot; &quot;summarise_each_&quot; ## [256] &quot;summarise_if&quot; &quot;summarize&quot; &quot;summarize_&quot; ## [259] &quot;summarize_all&quot; &quot;summarize_at&quot; &quot;summarize_each&quot; ## [262] &quot;summarize_each_&quot; &quot;summarize_if&quot; &quot;sym&quot; ## [265] &quot;syms&quot; &quot;tally&quot; &quot;tally_&quot; ## [268] &quot;tbl&quot; &quot;tbl_df&quot; &quot;tbl_nongroup_vars&quot; ## [271] &quot;tbl_ptype&quot; &quot;tbl_sum&quot; &quot;tbl_vars&quot; ## [274] &quot;tibble&quot; &quot;top_frac&quot; &quot;top_n&quot; ## [277] &quot;transmute&quot; &quot;transmute_&quot; &quot;transmute_all&quot; ## [280] &quot;transmute_at&quot; &quot;transmute_if&quot; &quot;tribble&quot; ## [283] &quot;type_sum&quot; &quot;ungroup&quot; &quot;union&quot; ## [286] &quot;union_all&quot; &quot;validate_grouped_df&quot; &quot;validate_rowwise_df&quot; ## [289] &quot;vars&quot; &quot;with_groups&quot; &quot;with_order&quot; ## [292] &quot;wrap_dbplyr_obj&quot; citation(package=&quot;dplyr&quot;) ## ## To cite package &#39;dplyr&#39; in publications use: ## ## Wickham H, François R, Henry L, Müller K (2022). _dplyr: A Grammar of ## Data Manipulation_. R package version 1.0.10, ## &lt;https://CRAN.R-project.org/package=dplyr&gt;. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {dplyr: A Grammar of Data Manipulation}, ## author = {Hadley Wickham and Romain François and Lionel Henry and Kirill Müller}, ## year = {2022}, ## note = {R package version 1.0.10}, ## url = {https://CRAN.R-project.org/package=dplyr}, ## } 8.7 Further Resources Chapter 5: Data Transformation in R for Data Science Data transformation cheat sheet Chapter 16: Date and times in R for Data Science "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
